# 4/1/2025 9:08 PM
I just finished reading over the entire project description to understand what the expectations are. I definitely think that it's very involved in terms of making sure that everything is synchronized. Clearly, the safe and the manager are shared resources so they will need to utilize semaphores, but I am not sure if there is anything else that needs to be protected. Also, it needs to be possible for any of the customer threads to communicate with any of the tellers because it just depends on who is free at the right time. I also need to have a global track of how many customers have been serviced so that the bank can close at the appropriate time. Right now, I don't really have a sense of how I'll scale it but I think I'm only going to start off with one customer and one teller and see if I can figure out the interactions between them. From there, I think I will be able to figure out how to implement the safe and the manager. I just think that I'll be overlooking a lot of the small details right now but I want to get started by creating classes for a Teller and Customer and just having the Customer tell the Teller what action they want to perform.

# 4/1/2025 10:25 PM
Okay, I started out by making two classes - one for Teller and one for Customer. I just worked on being able to initialize them with IDs, and then also once the Teller starts, it will print out that it is ready. I think that I will also include a flag so that customers are notified that there is a Teller ready to help them. I need global variables to keep track of which customers are waiting for a teller and then also to keep track of who has been served so that I can stop when that list reaches a certain size. Also, I will just have customers make a random choice of what type of transaction they are doing and then I'll add them to the waiting list. After that, I'll see if I can alert the tellers that there is a waiting customer - maybe I can do this based on a Thread event?

# 4/1/2025 10:49 PM
I ended up using the threading.Condition() module to communicate between the Customer and Teller. Basically, with the condition I add Customers to a global list of 'waiting' and this should notify the Teller to serve the customer. However, I can tell that the Customer is being added to the waiting list but I don't know why it's not waking up the Teller and the program just terminates somewhere in the middle and it freezes so I need to figure out why it's doing that.

# 4/1/2025 11:00 PM
I was just missing the condition.notify() call but once I added that, the Teller was being notified that there was a waiting customer. I also added in the print statements that the Teller goes through, but right it's just a linear progress because I only have one Teller and one Customer. I think now is a good time to add the Semaphores for the safe and the manager just so I can figure out how to implement that. Only 1 thread can interact with a manager and two in the safe so I can easily create those semaphores. And then, I think I'll use the .acquire() functionality to "lock" and "unlock" the semaphore. It'll be a conditional for the manager based on the transaction type and then the safe will always have to be acquired. Also, I need to add some wait times to the safe and the manager permission.

# 4/1/2025 11:46 PM
I think that I'm done working on the project for the night. So essentially, I was able to use the different semaphores - one for manager, one for the bank "door" and then one for the safe. I actually thought that it was pretty easy to use because you just tell it how many threads it should handle and then acquire() and release() the Semaphore whenever you need and it's pretty cool that you can implement mutual exclusion with it. Whhenever the Semaphore couldn't be acquired, I just had the Customer/Teller wait for 100 ms so that it's not burning too much of the CPU power rather than just using a pass instruction. Then, I also went through and added all of the print statements for each of the actions that the Teller/Customer has to do based on the sample run that was provided just so I could also visualize the flow of events better and figure out where things need to be acquired or when to sleep. I also added communication between the Customer and Teller by assigning the Teller ID within the Teller class whenever the Teller takes on the Customer and then also with an Event to notify the Customer when the transaction is done. With that, I think I was able to simulate a succesful run between just one Customer and one Teller. Next, I want to increase it to 3 tellers and still just one customer so that I can figure out when the bank needs to open and close and then I will finally scale the customers up last. 

# 4/2/2025 2:32 PM
Okay, I have about an hour to add some more functionality. Right now, I don't want to deal with increasing the number of customers but I want to figure out how to increase the number of Tellers. I'll just increase it to 2. One thing that I'll have to add is making sure they are both ready before saying that the bank is open. And then I also have to figure out how to allocate the Customers. First, I'll just deal with making sure that they are both ready. I think that allocating the customers will be somewhat of a race condition because it's whichever Teller gets to the customer first. But also, that shouldn't matter too much as long as the Teller is free to service the customer. So that should just be a simple conditional. To see if the bank is open, I think I can just make a global flag and also some global integer to increment to be the amount of Tellers we want before enabling the flag.

# 4/2/2025 3:03 PM
Okay, I ended up being able to upgrade it to 3 Tellers. I first just started out with 2 and I realized it's not an issue of which Teller will get a Customer because they get them from a global list which is modified once a Teller takes a Customer so multiple Tellers will never service the same Customer. The harder part was figuring out how to wait until all 3 Teller threads were ready before starting to service Customers. For this, I had to use a threading.Barrier() and threading.Event(). Using a global counter and flag without proper synchronization (like a Condition or Lock) didn't work because it led to race conditions and gave incorrect output. Barrier was used to make sure that all 3 Tellers were ready before Customers entered the bank. Once all Tellers reached the barrier, one of them triggered an Event to signal to the Customers that they could begin entering. Then I was able to just increase that to 3 so all the Tellers are fully functional except for figuring out how to leave when 50 Customers are serviced. Now I'm just going to try increasing the Customer count to 2. All this should take is putting the Teller code into a loop while there are still waiting Customers so I think it should be straighforward.

# 4/2/2025 4:36 PM
I think that I have it working for two separate Customers. This was actually really hard to do because I put the Teller code into an infinite loop so that it keeps servicing customers but it was hard to figure out when to end and return, and also to make sure that this happens after the customers all leave the bank. I created a global variable called customers_left to keep track of how many customers had left the bank after being serviced. I also used a customerLimit lock to protect access to that variable so that multiple Customers wouldnâ€™t mess it up by changing it at the same time. Each customer increases the customers_left count only after they print that they left the bank. Then, in the teller loop, I check if customers_left has reached the total number of customers (2 for now). If it has, the teller prints a message saying they're leaving for the day and exits the loop. That way, the tellers only leave once all Customers have left the bank. Next, I just want to make it 3 Customers because that way I can make the safe Semaphore is working properly based on the output. It's a little hard to make sense of everything because there is so much output for this project. So, I think if I just have 3, I can make sure that there are never more than 2 Tellers in the safe at a time. Then I think I will check 4 just because there are 3 Tellers so I can ensure that the Customer waits properly. Once I verify the output for those combinations, I think that I can just increase the customer number to 50. I definitely have learned a lot of synchronization and using Barrier, Event, and Locks  because I had to coordinate multiple threads so they could safely share resources.

